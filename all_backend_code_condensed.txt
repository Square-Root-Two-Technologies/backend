// --- File Structure ---
{
  "app.yaml": true,
  "config": {
    "cloudinary.js": true
  },
  "config.env": true,
  "db.js": true,
  "index.js": true,
  "middleware": {
    "fetchuser.js": true,
    "isAdmin.js": true,
    "restrictToOwnerOrAdmin.js": true,
    "upload.js": true
  },
  "migration_add_categories.js": true,
  "models": {
    "Category.js": true,
    "Note.js": true,
    "User.js": true
  },
  "package.json": true,
  "populateTestData.js": true,
  "routes": {
    "auth.js": true,
    "categories.js": true,
    "notes.js": true
  },
  "setup_initial_categories.js": true
}

// --- Aggregated Code Content (Comments and Blank Lines Removed) ---

// FILE: app.yaml
runtime: nodejs20
env_variables:
  DATABASE: "mongodb+srv://tanvirraihanislam2020:HBvqo4zAq5WwUqCZ@website2025.vgtt4.mongodb.net/?retryWrites=true&w=majority&appName=Website2025"
  JWT_SECRET: "Harryisagoodb$oy"
  PORT: "5000"
handlers:
  - url: /.*
    script: auto
network:
  forwarded_ports:
    - 5000

// FILE: config.env
DATABASE = mongodb+srv://tanvirraihanislam2020:HBvqo4zAq5WwUqCZ@website2025.vgtt4.mongodb.net/?retryWrites=true&w=majority&appName=Website2025
JWT_SECRET = Harryisagoodb$oy

CLOUDINARY_CLOUD_NAME=dp5bafsoz
CLOUDINARY_API_KEY=618714485493137
CLOUDINARY_API_SECRET=HNxI_x85m4Gu0-xYVaYo0DBv1qI


REACT_APP_GOOGLE_CLIENT_ID = 344045907409-pm7dp05kuvtckvepnh064r4bnfujrj6d.apps.googleusercontent.com

GOOGLE_CLIENT_ID = 344045907409-pm7dp05kuvtckvepnh064r4bnfujrj6d.apps.googleusercontent.com

// FILE: config/cloudinary.js
const cloudinary = require("cloudinary").v2;
const dotenv = require("dotenv");
dotenv.config({ path: "./config.env" }); 
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
  secure: true, 
});
console.log("Cloudinary Configured:", !!process.env.CLOUDINARY_CLOUD_NAME); 
module.exports = cloudinary;

// FILE: db.js
const mongoose = require("mongoose");
const dotenv = require("dotenv");
dotenv.config({ path: "./config.env" });
const mongoURI = process.env.DATABASE;
mongoose.set("strictQuery", false);
const connectToMongo = () => {
  mongoose
    .connect(mongoURI, () => {
      console.log("Connected to Mongo Successfully");
    })
    .catch((err) => {
      console.log("no connection");
      console.log(err);
    });
};
module.exports = connectToMongo;

// FILE: index.js
require("dotenv").config({ path: "./config.env" });
const connectToMongo = require("./db");
const express = require("express");
var cors = require("cors");
connectToMongo();
const app = express();
const port = 5000;
app.use(cors());
app.use(express.json());
app.use("/api/auth", require("./routes/auth"));
app.use("/api/notes", require("./routes/notes"));
app.use("/api/categories", require("./routes/categories"));
app.listen(port, () => {
  console.log(`squareroottwo backend listening at http://localhost:${port}`);
});
app.get("/ping", (req, res) => {
  console.log("Ping request received at:", new Date().toISOString()); 
  res.status(200).send("OK"); 
});

// FILE: middleware/fetchuser.js
const jwt = require("jsonwebtoken");
require("dotenv").config({ path: "../config.env" }); 
const JWT_SECRET = process.env.JWT_SECRET;
const fetchuser = (req, res, next) => {
  const token = req.header("auth-token");
  if (!token) {
    res.status(401).send({ error: "Please authenticate using a valid token" });
  }
  try {
    const data = jwt.verify(token, JWT_SECRET);
    req.user = data.user;
    next();
  } catch (error) {
    res.status(401).send({ error: "Please authenticate using a valid token" });
  }
};
module.exports = fetchuser;

// FILE: middleware/isAdmin.js
const User = require("../models/User"); 
const isAdmin = async (req, res, next) => {
  if (!req.user || !req.user.id) {
    return res
      .status(401)
      .json({ success: false, error: "Authentication required." });
  }
  try {
    const user = await User.findById(req.user.id).select("role");
    if (!user) {
      return res.status(401).json({ success: false, error: "User not found." });
    }
    if (user.role !== "admin") {
      return res
        .status(403)
        .json({ success: false, error: "Forbidden: Admin access required." });
    }
    req.requestingUserRole = user.role;
    next(); 
  } catch (error) {
    console.error("Error in isAdmin middleware:", error);
    res
      .status(500)
      .json({ success: false, error: "Server error checking user role." });
  }
};
module.exports = isAdmin;

// FILE: middleware/restrictToOwnerOrAdmin.js
const mongoose = require("mongoose");
const Note = require("../models/Note");
const User = require("../models/User");
const restrictToOwnerOrAdmin = async (req, res, next) => {
  if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
    return res.status(400).json({ error: "Invalid Note ID" });
  }
  const note = await Note.findById(req.params.id);
  if (!note) return res.status(404).json({ error: "Not Found" });
  const user = await User.findById(req.user.id).select("role");
  if (!user) return res.status(401).json({ error: "User not found" });
  if (note.user.toString() !== req.user.id && user.role !== "admin") {
    return res.status(401).json({ error: "Not Allowed" });
  }
  req.note = note; 
  req.requestingUser = user; 
  next();
};
module.exports = restrictToOwnerOrAdmin;

// FILE: middleware/upload.js
const multer = require("multer");
const storage = multer.memoryStorage();
const fileFilter = (req, file, cb) => {
  if (file.mimetype.startsWith("image/")) {
    cb(null, true); 
  } else {
    cb(new Error("Not an image! Please upload only images."), false); 
  }
};
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, 
  },
});
module.exports = upload;

// FILE: migration_add_categories.js
require("dotenv").config({ path: "./config.env" });
const mongoose = require("mongoose");
const Note = require("./models/Note");
const Category = require("./models/Category");
const mongoURI = process.env.DATABASE;
async function runMigration() {
  console.log("Connecting to MongoDB...");
  await mongoose.connect(mongoURI);
  console.log("Connected to MongoDB successfully.");
  let updatedCount = 0;
  let skippedCount = 0;
  let errorCount = 0;
  try {
    console.log("Fetching all categories...");
    const categories = await Category.find({});
    if (categories.length === 0) {
      console.error(
        'ERROR: No categories found in the database. Please create categories matching the old "type" values first.',
      );
      return;
    }
    const categoryMap = categories.reduce((map, cat) => {
      map[cat.name.toLowerCase()] = cat._id;
      return map;
    }, {});
    console.log(
      `Found ${categories.length} categories. Map created:`,
      Object.keys(categoryMap),
    );
    console.log("Starting note migration...");
    const batchSize = 100;
    let processedNotes = 0;
    let hasMoreNotes = true;
    let lastId = null;
    while (hasMoreNotes) {
      const query = {
        $or: [
          { category: { $exists: false } }, 
          { type: { $exists: true } }, 
        ],
      };
      if (lastId) {
        query._id = { $gt: lastId }; 
      }
      const notesBatch = await Note.find(query)
        .select("_id type") 
        .limit(batchSize)
        .sort({ _id: 1 }); 
      if (notesBatch.length === 0) {
        hasMoreNotes = false;
        break;
      }
      lastId = notesBatch[notesBatch.length - 1]._id;
      processedNotes += notesBatch.length;
      console.log(
        `Processing batch of ${notesBatch.length} notes (Total processed: ${processedNotes})...`,
      );
      for (const note of notesBatch) {
        if (!note.type) {
          console.warn(
            `Note ID ${note._id} has no 'type' field and no 'category'. Skipping.`,
          );
          skippedCount++;
          continue;
        }
        const typeLower = note.type.toLowerCase();
        const categoryId = categoryMap[typeLower];
        if (categoryId) {
          try {
            const updateResult = await Note.updateOne(
              { _id: note._id },
              {
                $set: { category: categoryId }, 
                $unset: { type: "" }, 
              },
            );
            if (updateResult.modifiedCount === 1) {
              updatedCount++;
            } else {
              console.warn(
                `Note ID ${note._id} was found but not modified. Result:`,
                updateResult,
              );
              skippedCount++;
            }
          } catch (updateError) {
            console.error(`Error updating Note ID: ${note._id}`, updateError);
            errorCount++;
          }
        } else {
          console.warn(
            `No category found for type "${note.type}" (Note ID: ${note._id}). Skipping.`,
          );
          skippedCount++;
        }
      }
      console.log(
        `Batch processed. Updated: ${updatedCount}, Skipped: ${skippedCount}, Errors: ${errorCount}`,
      );
    }
    console.log("--- Migration Summary ---");
    console.log(`Total Notes Processed (approx): ${processedNotes}`);
    console.log(`Successfully Updated: ${updatedCount}`);
    console.log(`Skipped (no type/category or no match): ${skippedCount}`);
    console.log(`Errors during update: ${errorCount}`);
    console.log("Migration finished.");
  } catch (error) {
    console.error("An error occurred during migration:", error);
  } finally {
    console.log("Disconnecting from MongoDB...");
    await mongoose.disconnect();
    console.log("Disconnected.");
  }
}
runMigration();

// FILE: models/Category.js
const mongoose = require("mongoose");
const { Schema } = mongoose;
const CategorySchema = new Schema(
  {
    name: {
      type: String,
      required: [true, "Category name is required."],
      trim: true,
      minlength: [2, "Category name must be at least 2 characters long."],
      maxlength: [50, "Category name cannot exceed 50 characters."],
    },
    parent: {
      type: Schema.Types.ObjectId,
      ref: "Category",
      default: null,
    },
    description: {
      type: String,
      trim: true,
      maxlength: [200, "Description cannot exceed 200 characters."],
      default: "",
    },
  },
  {
    timestamps: true,
  },
);
CategorySchema.index({ parent: 1, name: 1 }, { unique: true });
const Category = mongoose.model("Category", CategorySchema);
module.exports = Category;

// FILE: models/Note.js
const mongoose = require("mongoose");
const { Schema } = mongoose;
const NotesSchema = new Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "user",
      required: true, 
    },
    title: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
      required: true,
    },
    tag: {
      type: String,
      default: "General",
      trim: true,
    },
    category: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Category", 
      required: [true, "A category is required for each note."],
      index: true, 
    },
    date: {
      type: Date,
      default: Date.now,
    },
    readTimeMinutes: {
      type: Number,
      required: false, 
      min: [0, "Read time cannot be negative"],
    },
    isFeatured: {
      type: Boolean,
      default: false,
      index: true,
    },
    slug: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
  },
  {
    timestamps: true, 
  },
);
NotesSchema.pre("save", function (next) {
  if (this.isModified("description") || this.isNew) {
    const words = this.description.split(/\s+/).filter(Boolean).length;
    const wordsPerMinute = 200;
    this.readTimeMinutes = Math.max(1, Math.ceil(words / wordsPerMinute));
  }
  next();
});
module.exports = mongoose.model("notes", NotesSchema); 

// FILE: models/User.js
const mongoose = require("mongoose");
const { Schema } = mongoose;
const UserSchema = new Schema({
  name: {
    type: String,
    required: true,
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true, 
    trim: true,
  },
  password: {
    type: String,
    required: function () {
      return !this.googleId;
    },
    select: false,
  },
  date: {
    type: Date,
    default: Date.now,
  },
  country: {
    type: String,
    required: false,
  },
  city: {
    type: String,
    required: false,
  },
  about: {
    type: String,
    required: false,
    default: "about is empty",
  },
  role: {
    type: String,
    required: true,
    enum: ["user", "admin"], 
    default: "user", 
  },
  profilePictureUrl: {
    type: String,
    default: null,
  },
  profilePicturePublicId: {
    type: String,
    default: null,
  },
  googleId: {
    type: String,
    unique: true, 
    sparse: true,
  },
});
UserSchema.methods.toJSON = function () {
  var obj = this.toObject();
  delete obj.password;
  return obj;
};
const User = mongoose.model("user", UserSchema);
module.exports = User;

// FILE: package.json
{"name":"squareroorwo_backend","version":"1.0.0","description":"Square Root Two Technologies","main":"index.js","scripts":{"test":"echo \"Error: no test specified\" && exit 1","start":"node index.js"},"author":"","license":"ISC","dependencies":{"bcryptjs":"^2.4.3","cloudinary":"^2.6.0","cors":"^2.8.5","dotenv":"^16.5.0","express":"^4.17.1","express-validator":"^6.12.1","google-auth-library":"^9.15.1","jsonwebtoken":"^9.0.0","lorem-ipsum":"^2.0.8","mongoose":"^6.13.8","multer":"^1.4.5-lts.2","slugify":"^1.6.6"},"devDependencies":{"nodemon":"^2.0.12"}}

// FILE: populateTestData.js
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const { LoremIpsum } = require("lorem-ipsum");
const slugify = require("slugify");
const dotenv = require("dotenv");
dotenv.config({ path: "./config.env" });
const connectToMongo = require("./db");
const User = require("./models/User");
const Note = require("./models/Note");
const Category = require("./models/Category");
connectToMongo();
const lorem = new LoremIpsum({
  sentencesPerParagraph: { max: 8, min: 4 },
  wordsPerSentence: { max: 16, min: 4 },
});
const testUsers = [
  {
    name: "Admin User",
    email: "admin@example.com",
    password: "admin123", 
    country: "USA",
    city: "New York",
    about: "I am the admin.",
    role: "admin",
  },
];
async function createTestUsers() {
  try {
    console.log("Clearing existing users...");
    await User.deleteMany({}); 
    console.log("Creating test admin user...");
    const salt = await bcrypt.genSalt(10);
    const secPass = await bcrypt.hash(testUsers[0].password, salt);
    const user = await User.create({
      name: testUsers[0].name,
      email: testUsers[0].email,
      password: secPass,
      country: testUsers[0].country,
      city: testUsers[0].city,
      about: testUsers[0].about,
      role: testUsers[0].role,
    });
    console.log(`Created user: ${user.name} (ID: ${user._id})`);
    return [user]; 
  } catch (error) {
    console.error("Error creating user:", error);
    process.exit(1); 
  }
}
const initialTopLevelCategories = [
  {
    name: "JavaScript",
    description: "Posts related to JavaScript programming.",
  },
  {
    name: "Salesforce",
    description: "Posts about Salesforce CRM and platform.",
  },
  { name: "Sociology", description: "Posts related to sociological topics." },
  {
    name: "Life",
    description: "Posts about life experiences and reflections.",
  },
  { name: "Technology", description: "General technology posts." },
  {
    name: "Creative",
    description: "Posts about creative projects or processes.",
  },
  { name: "Tutorial", description: "How-to guides and tutorials." },
  { name: "News", description: "News related updates." },
  { name: "General", description: "General uncategorized posts." }, 
];
const subCategoryDefinitions = [
  {
    parentName: "Technology",
    name: "Web Development",
    description: "Frontend and backend web technologies.",
  },
  {
    parentName: "Technology",
    name: "Cloud Computing",
    description: "AWS, Azure, GCP, and other cloud platforms.",
  },
  {
    parentName: "Salesforce",
    name: "Apex",
    description: "Salesforce Apex programming language.",
  },
  {
    parentName: "Salesforce",
    name: "Flows",
    description: "Salesforce Flow automation.",
  },
  {
    parentName: "JavaScript",
    name: "React",
    description: "React library for building user interfaces.",
  },
  {
    parentName: "JavaScript",
    name: "Node.js",
    description: "Node.js runtime environment.",
  },
];
async function setupTopLevelCategories() {
  let createdCount = 0;
  let skippedCount = 0;
  const createdOrFoundCategories = [];
  console.log("Attempting to create/find initial top-level categories...");
  for (const catData of initialTopLevelCategories) {
    try {
      const existing = await Category.findOne({
        name: { $regex: `^${catData.name}$`, $options: "i" },
        parent: null, 
      });
      if (existing) {
        console.log(
          `Top-level category "${catData.name}" already exists. Skipping creation.`,
        );
        skippedCount++;
        createdOrFoundCategories.push(existing); 
      } else {
        const newCategory = new Category({
          ...catData,
          parent: null, 
        });
        await newCategory.save();
        console.log(`Created top-level category: "${newCategory.name}"`);
        createdCount++;
        createdOrFoundCategories.push(newCategory); 
      }
    } catch (error) {
      console.error(
        `Error processing top-level category "${catData.name}":`,
        error,
      );
    }
  }
  console.log("--- Top-Level Category Setup Summary ---");
  console.log(`Created: ${createdCount}`);
  console.log(`Skipped (already existed): ${skippedCount}`);
  return createdOrFoundCategories;
}
async function setupSubCategories(parentCategories) {
  let createdCount = 0;
  let skippedCount = 0;
  let errorCount = 0;
  const createdOrFoundSubCategories = [];
  const parentMap = parentCategories.reduce((map, cat) => {
    map[cat.name.toLowerCase()] = cat._id;
    return map;
  }, {});
  console.log("\nAttempting to create subcategories...");
  for (const subCatData of subCategoryDefinitions) {
    const parentId = parentMap[subCatData.parentName.toLowerCase()];
    if (!parentId) {
      console.warn(
        `Parent category "${subCatData.parentName}" not found for subcategory "${subCatData.name}". Skipping.`,
      );
      errorCount++;
      continue;
    }
    try {
      const existingSub = await Category.findOne({
        name: { $regex: `^${subCatData.name}$`, $options: "i" },
        parent: parentId,
      });
      if (existingSub) {
        console.log(
          `Subcategory "${subCatData.name}" under "${subCatData.parentName}" already exists. Skipping.`,
        );
        skippedCount++;
        createdOrFoundSubCategories.push(existingSub);
      } else {
        const newSubCategory = new Category({
          name: subCatData.name,
          description: subCatData.description,
          parent: parentId,
        });
        await newSubCategory.save();
        console.log(
          `Created subcategory: "${newSubCategory.name}" under "${subCatData.parentName}"`,
        );
        createdCount++;
        createdOrFoundSubCategories.push(newSubCategory);
      }
    } catch (error) {
      console.error(`Error creating subcategory "${subCatData.name}":`, error);
      errorCount++;
    }
  }
  console.log("--- Subcategory Setup Summary ---");
  console.log(`Created: ${createdCount}`);
  console.log(`Skipped (already existed): ${skippedCount}`);
  console.log(`Errors (e.g., parent not found): ${errorCount}`);
  return createdOrFoundSubCategories;
}
async function createTestNotes(users, allCategories) {
  try {
    console.log("\nClearing existing notes...");
    await Note.deleteMany({}); 
    const notesCount = 150; 
    const user = users[0]; 
    if (!user || !user._id) {
      console.error(
        "Admin user was not created successfully. Cannot create notes.",
      );
      process.exit(1);
    }
    if (!allCategories || allCategories.length === 0) {
      console.error("No categories provided to createTestNotes function.");
      process.exit(1);
    }
    console.log(
      `Starting creation of ${notesCount} notes for user ${user.email}, distributed across ${allCategories.length} categories...`,
    );
    for (let i = 0; i < notesCount; i++) {
      const randomCategory =
        allCategories[Math.floor(Math.random() * allCategories.length)];
      const categoryId = randomCategory._id;
      const categoryName = randomCategory.name; 
      const title = `${categoryName} Post ${i + 1}: ${lorem.generateWords(
        Math.floor(Math.random() * 3) + 2, 
      )}`;
      const description = lorem.generateParagraphs(
        Math.floor(Math.random() * 2) + 1,
      ); 
      const tag = lorem.generateWords(1);
      const isFeatured = Math.random() < 0.15; 
      let baseSlug = slugify(title, {
        lower: true, 
        strict: true, 
        remove: /[*+~.()'"!:@]/g, 
      });
      if (!baseSlug) {
        baseSlug = `note-${Date.now()}-${i}`;
      }
      let slug = baseSlug;
      let counter = 1;
      let existingNote = await Note.findOne({ slug: slug });
      while (existingNote) {
        counter++;
        slug = `${baseSlug}-${counter}`;
        existingNote = await Note.findOne({ slug: slug });
      }
      const noteData = {
        user: user._id,
        title: title,
        slug: slug, 
        description,
        tag,
        category: categoryId, 
        isFeatured,
      };
      try {
        await Note.create(noteData);
        if ((i + 1) % 25 === 0) {
          console.log(`Created note ${i + 1}/${notesCount}...`);
        }
      } catch (noteError) {
        if (
          noteError.code === 11000 &&
          noteError.keyPattern &&
          noteError.keyPattern.slug
        ) {
          console.warn(
            `WARN: Slug collision occurred for title "${title}" (Slug: ${slug}) even after check. Skipping this note.`,
          );
        } else {
          console.error(
            `Error creating note "${title}" (Category: ${categoryName}, Slug: ${slug}):`,
            noteError.message,
          );
        }
      }
    }
    console.log(`Successfully attempted creation of ${notesCount} notes.`);
  } catch (error) {
    console.error("Error during the note creation process:", error);
    process.exit(1); 
  }
}
async function main() {
  console.log("Starting test data population...");
  try {
    const topLevelCategories = await setupTopLevelCategories();
    const subCategories = await setupSubCategories(topLevelCategories);
    const allCategories = [...topLevelCategories, ...subCategories];
    if (allCategories.length === 0) {
      console.error(
        "ERROR: No categories found or created. Cannot proceed with note creation.",
      );
      process.exit(1);
    }
    console.log(
      `\nTotal categories available for notes: ${allCategories.length}`,
    );
    const users = await createTestUsers();
    if (users && users.length > 0) {
      await createTestNotes(users, allCategories); 
      console.log("\nTest data population completed successfully!");
    } else {
      console.error("User creation failed, skipping note creation.");
    }
  } catch (error) {
    console.error("An error occurred during the main execution:", error);
  } finally {
    await mongoose.connection.close();
    console.log("\nDatabase connection closed.");
  }
}
main();

// FILE: routes/auth.js
const express = require("express");
const User = require("../models/User");
const router = express.Router();
const { body, validationResult } = require("express-validator");
const bcrypt = require("bcryptjs");
var jwt = require("jsonwebtoken");
var fetchuser = require("../middleware/fetchuser");
const upload = require("../middleware/upload");
const cloudinary = require("../config/cloudinary");
const { OAuth2Client } = require("google-auth-library");
const dotenv = require("dotenv");
dotenv.config({ path: "../config.env" }); 
const JWT_SECRET = process.env.JWT_SECRET;
const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID; 
if (!GOOGLE_CLIENT_ID) {
  console.error("FATAL ERROR: GOOGLE_CLIENT_ID is not defined in config.env");
}
const client = new OAuth2Client(GOOGLE_CLIENT_ID); 
router.get("/", (req, res) => {
  console.log(
    "hello you have reached the offices of square root two technologies",
  );
});
router.post(
  "/createuser",
  [
    body("name", "Enter a valid name").isLength({ min: 3 }),
    body("email", "Enter a valid email").isEmail(),
    body("password", "Password must be atleast 5 characters").isLength({
      min: 5,
    }),
    body("country", "Enter a valid country").isLength({ min: 2 }),
    body("city", "Enter a valid city").isLength({ min: 1 }),
    body("about"),
  ],
  async (req, res) => {
    let success = false;
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success, errors: errors.array() });
    }
    try {
      let user = await User.findOne({ email: req.body.email });
      if (user) {
        return res.status(400).json({
          success,
          error: "Sorry a user with this email already exists",
        });
      }
      const salt = await bcrypt.genSalt(10);
      const secPass = await bcrypt.hash(req.body.password, salt);
      const { name, email, password, country, city, about } = req.body;
      user = await User.create({
        name: name,
        password: secPass,
        email: email,
        country: country,
        city: city,
        about: about,
      });
      const data = {
        user: {
          id: user.id,
        },
      };
      const authtoken = jwt.sign(data, JWT_SECRET, { expiresIn: "1h" });
      success = true;
      res.json({ success, authtoken });
    } catch (error) {
      console.error("Error in /createuser:", error);
      res.status(500).send("Internal Server Error");
    }
  },
);
router.post(
  "/login",
  [
    body("email", "Enter a valid email").isEmail(),
    body("password", "Password cannot be blank").exists(),
  ],
  async (req, res) => {
    let success = false;
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    const { email, password } = req.body;
    try {
      let user = await User.findOne({ email }).select("+password");
      if (!user) {
        success = false;
        return res
          .status(400)
          .json({ error: "Please try to login with correct credentials" });
      }
      const passwordCompare = await bcrypt.compare(password, user.password);
      if (!passwordCompare) {
        success = false;
        return res.status(400).json({
          success,
          error: "Please try to login with correct credentials",
        });
      } else {
        console.log("true!");
      }
      const data = {
        user: {
          id: user.id,
        },
      };
      const authtoken = jwt.sign(data, JWT_SECRET, { expiresIn: "1h" });
      success = true;
      res.json({ success, authtoken });
    } catch (error) {
      console.error("Error in /login:", error);
      res.status(500).send("Internal Server Error");
    }
  },
);
router.post("/getuser", fetchuser, async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findById(userId).select("-password "); 
    if (!user) {
      return res.status(404).send("User not found");
    }
    res.send(user); 
  } catch (error) {
    console.error(error.message); 
    res.status(500).send("Internal Server Error");
  }
});
router.put(
  "/profile", 
  fetchuser, 
  [
    body("name", "Name must be at least 3 characters")
      .optional()
      .isLength({ min: 3 }),
    body("country", "Country must be at least 2 characters")
      .optional()
      .isLength({ min: 2 }),
    body("city", "City must be at least 1 character")
      .optional()
      .isLength({ min: 1 }),
    body("about", "About must be a string").optional().isString(),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    try {
      const userId = req.user.id;
      const { name, country, city, about } = req.body;
      const updatedFields = {};
      if (name !== undefined) updatedFields.name = name;
      if (country !== undefined) updatedFields.country = country;
      if (city !== undefined) updatedFields.city = city;
      if (about !== undefined) updatedFields.about = about;
      if (Object.keys(updatedFields).length === 0) {
        return res.status(400).json({ error: "No update fields provided" });
      }
      const updatedUser = await User.findByIdAndUpdate(
        userId, 
        { $set: updatedFields }, 
        { new: true }, 
      ).select("-password"); 
      if (!updatedUser) {
        return res.status(404).json({ error: "User not found" });
      }
      res.status(200).json({ success: true, user: updatedUser });
    } catch (error) {
      console.error("Error updating profile:", error.message);
      res.status(500).send("Internal Server Error");
    }
  },
);
router.put(
  "/profile/picture",
  fetchuser, 
  upload.single("profilePic"), 
  async (req, res) => {
    try {
      const userId = req.user.id;
      if (!req.file) {
        return res
          .status(400)
          .json({ success: false, error: "No image file uploaded." });
      }
      const user = await User.findById(userId);
      if (!user) {
        return res
          .status(404)
          .json({ success: false, error: "User not found." });
      }
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: `profile_pictures/${userId}`, 
          public_id: `user_${userId}_avatar`, 
          overwrite: true, 
          format: "webp", 
          transformation: [
            { width: 200, height: 200, crop: "fill", gravity: "face" },
          ],
        },
        async (error, result) => {
          if (error) {
            console.error("Cloudinary upload error:", error);
            return res.status(500).json({
              success: false,
              error: "Failed to upload image to cloud.",
            });
          }
          if (!result) {
            console.error(
              "Cloudinary upload error: No result object returned.",
            );
            return res.status(500).json({
              success: false,
              error: "Cloud upload failed unexpectedly.",
            });
          }
          user.profilePictureUrl = result.secure_url;
          user.profilePicturePublicId = result.public_id;
          await user.save();
          const updatedUserInfo = await User.findById(userId).select(
            "-password",
          );
          res.status(200).json({ success: true, user: updatedUserInfo });
        },
      );
      uploadStream.end(req.file.buffer);
    } catch (error) {
      console.error("Error in /profile/picture:", error);
      if (error instanceof multer.MulterError) {
        return res.status(400).json({
          success: false,
          error: `File upload error: ${error.message}`,
        });
      }
      if (error.message === "Not an image! Please upload only images.") {
        return res.status(400).json({ success: false, error: error.message });
      }
      res.status(500).json({ success: false, error: "Internal Server Error" });
    }
  },
);
router.post("/google-login", async (req, res) => {
  const { token } = req.body; 
  if (!token) {
    return res
      .status(400)
      .json({ success: false, error: "ID token is required." });
  }
  if (!GOOGLE_CLIENT_ID) {
    console.error("Google Client ID is missing in backend config.");
    return res
      .status(500)
      .json({ success: false, error: "Server configuration error." });
  }
  try {
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: GOOGLE_CLIENT_ID, 
    });
    const payload = ticket.getPayload();
    if (!payload) {
      throw new Error("Invalid Google token payload");
    }
    const googleUserId = payload["sub"]; 
    const email = payload["email"];
    const name = payload["name"];
    const picture = payload["picture"]; 
    if (!email) {
      throw new Error("Email not found in Google token payload");
    }
    let user = await User.findOne({ email: email });
    if (user) {
      let needsSave = false;
      if (!user.googleId) {
        user.googleId = googleUserId;
        needsSave = true;
      }
      if (
        picture &&
        (!user.profilePictureUrl || user.profilePictureUrl !== picture)
      ) {
        user.profilePictureUrl = picture;
        needsSave = true;
      }
      if (name && user.name !== name) {
        user.name = name;
        needsSave = true;
      }
      if (needsSave) {
        await user.save();
        console.log(`Updated existing user ${email} during Google login.`);
      }
      console.log(`Existing user ${email} logged in via Google.`);
    } else {
      user = new User({
        googleId: googleUserId,
        email: email,
        name: name,
        profilePictureUrl: picture, 
        role: "user", 
      });
      await user.save();
      console.log(`New user ${email} created via Google Sign-In.`);
    }
    const jwtPayload = {
      user: {
        id: user.id,
      },
    };
    const authtoken = jwt.sign(jwtPayload, JWT_SECRET, { expiresIn: "1h" });
    res.json({ success: true, authtoken });
  } catch (error) {
    console.error("Google login verification error:", error);
    if (
      error.message.includes("Invalid token signature") ||
      error.message.includes("Token used too late") ||
      error.message.includes("Invalid Google token payload")
    ) {
      res
        .status(401)
        .json({ success: false, error: "Invalid or expired Google token." });
    } else if (error.message.includes("Email not found")) {
      res.status(400).json({
        success: false,
        error: "Could not retrieve email from Google token.",
      });
    } else {
      res.status(500).json({
        success: false,
        error: "Internal server error during Google authentication.",
      });
    }
  }
});
module.exports = router;

// FILE: routes/categories.js
const express = require("express");
const router = express.Router();
const Category = require("../models/Category");
const Note = require("../models/Note");
const User = require("../models/User");
const fetchuser = require("../middleware/fetchuser");
const isAdmin = require("../middleware/isAdmin");
const { body, validationResult } = require("express-validator");
const mongoose = require("mongoose");
router.get("/", async (req, res) => {
  try {
    const categories = await Category.find()
      .sort({ parent: 1, name: 1 })
      .lean();
    res.json({ success: true, categories });
  } catch (error) {
    console.error("Error fetching categories:", error);
    res
      .status(500)
      .json({ success: false, error: "Server Error fetching categories" });
  }
});
router.get("/tree", async (req, res) => {
  try {
    const allCategories = await Category.find().sort({ name: 1 }).lean();
    const categoryMap = {};
    const categoryTree = [];
    allCategories.forEach((category) => {
      categoryMap[category._id.toString()] = { ...category, children: [] };
    });
    allCategories.forEach((category) => {
      const categoryNode = categoryMap[category._id.toString()];
      if (category.parent && categoryMap[category.parent.toString()]) {
        categoryMap[category.parent.toString()].children.push(categoryNode);
      } else {
        categoryTree.push(categoryNode);
      }
    });
    res.json({ success: true, categoryTree });
  } catch (error) {
    console.error("Error fetching category tree:", error);
    res
      .status(500)
      .json({ success: false, error: "Server Error fetching category tree" });
  }
});
router.get("/:id", async (req, res) => {
  try {
    const categoryId = req.params.id;
    if (!mongoose.Types.ObjectId.isValid(categoryId)) {
      return res
        .status(400)
        .json({ success: false, error: "Invalid Category ID format" });
    }
    const category = await Category.findById(categoryId).populate(
      "parent",
      "name",
    ); 
    if (!category) {
      return res
        .status(404)
        .json({ success: false, error: "Category not found" });
    }
    res.json({ success: true, category });
  } catch (error) {
    console.error("Error fetching single category:", error);
    res
      .status(500)
      .json({ success: false, error: "Server Error fetching category" });
  }
});
router.post(
  "/",
  fetchuser,
  isAdmin,
  [
    body("name", "Category name is required and must be 2-50 characters")
      .trim()
      .isLength({ min: 2, max: 50 }),
    body("parent")
      .optional({ values: "falsy" })
      .if(body("parent").notEmpty())
      .isMongoId()
      .withMessage("Invalid parent category ID"),
    body("description")
      .optional()
      .trim()
      .isLength({ max: 200 })
      .withMessage("Description cannot exceed 200 characters"),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success: false, errors: errors.array() });
    }
    try {
      const { name, description } = req.body;
      const parentId =
        req.body.parent && mongoose.Types.ObjectId.isValid(req.body.parent)
          ? req.body.parent
          : null;
      if (parentId) {
        const parentCategory = await Category.findById(parentId);
        if (!parentCategory) {
          return res.status(400).json({
            success: false,
            errors: [{ msg: "Parent category not found", param: "parent" }],
          });
        }
      }
      const newCategory = new Category({
        name,
        parent: parentId,
        description,
      });
      await newCategory.save();
      res.status(201).json({ success: true, category: newCategory });
    } catch (error) {
      if (error.code === 11000) {
        return res.status(409).json({
          success: false,
          error: `A category with the same name already exists under this parent.`, 
        });
      }
      console.error("Error creating category:", error);
      res
        .status(500)
        .json({ success: false, error: "Server Error creating category" });
    }
  },
);
router.put(
  "/:id",
  fetchuser,
  isAdmin,
  [
    body("name", "Category name must be 2-50 characters")
      .optional()
      .trim()
      .isLength({ min: 2, max: 50 }),
    body("parent")
      .optional({ values: "falsy" })
      .if(body("parent").notEmpty())
      .isMongoId()
      .withMessage("Invalid parent category ID"),
    body("description")
      .optional()
      .trim()
      .isLength({ max: 200 })
      .withMessage("Description cannot exceed 200 characters"),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success: false, errors: errors.array() });
    }
    if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
      return res
        .status(400)
        .json({ success: false, error: "Invalid category ID format" });
    }
    try {
      const categoryId = req.params.id;
      const { name, parent, description } = req.body;
      const categoryToUpdate = await Category.findById(categoryId);
      if (!categoryToUpdate) {
        return res
          .status(404)
          .json({ success: false, error: "Category not found" });
      }
      const updateData = {};
      if (name !== undefined && name !== categoryToUpdate.name) {
        updateData.name = name;
      }
      if (parent !== undefined) {
        const parentId =
          parent && mongoose.Types.ObjectId.isValid(parent) ? parent : null;
        if (parentId && parentId.toString() === categoryId) {
          return res.status(400).json({
            success: false,
            error: "Cannot set category as its own parent.",
          });
        }
        if (parentId) {
          const parentCategory = await Category.findById(parentId);
          if (!parentCategory) {
            return res.status(400).json({
              success: false,
              errors: [{ msg: "Parent category not found", param: "parent" }],
            });
          }
        }
        updateData.parent = parentId;
      }
      if (description !== undefined) updateData.description = description;
      if (Object.keys(updateData).length === 0) {
        return res
          .status(400)
          .json({ success: false, error: "No fields provided for update." });
      }
      const updatedCategory = await Category.findByIdAndUpdate(
        categoryId,
        updateData,
        { new: true, runValidators: true },
      );
      res.json({ success: true, category: updatedCategory });
    } catch (error) {
      if (error.code === 11000) {
        return res.status(409).json({
          success: false,
          error: `Updating this category conflicts with an existing one (likely same name under the same parent).`,
        });
      }
      console.error("Error updating category:", error);
      res
        .status(500)
        .json({ success: false, error: "Server Error updating category" });
    }
  },
);
router.get("/tree/structured", async (req, res) => {
  try {
    const allCategories = await Category.find()
      .select("name parent description _id")
      .lean(); 
    const categoryMap = {};
    const categoryTree = [];
    allCategories.forEach((category) => {
      categoryMap[category._id.toString()] = { ...category, children: [] };
    });
    allCategories.forEach((category) => {
      const categoryNode = categoryMap[category._id.toString()];
      if (category.parent && categoryMap[category.parent.toString()]) {
        categoryMap[category.parent.toString()].children.push(categoryNode);
        categoryMap[category.parent.toString()].children.sort((a, b) =>
          a.name.localeCompare(b.name),
        );
      } else {
        categoryTree.push(categoryNode);
      }
    });
    categoryTree.sort((a, b) => a.name.localeCompare(b.name));
    res.json({ success: true, categoryTree });
  } catch (error) {
    console.error("Error fetching category tree:", error);
    res
      .status(500)
      .json({ success: false, error: "Server Error fetching category tree" });
  }
});
module.exports = router;

// FILE: routes/notes.js
const express = require("express");
const router = express.Router();
const fetchuser = require("../middleware/fetchuser");
const User = require("../models/User");
const Note = require("../models/Note");
const Category = require("../models/Category");
const { body, validationResult } = require("express-validator");
const mongoose = require("mongoose");
var restrictToOwnerOrAdmin = require("../middleware/restrictToOwnerOrAdmin");
const slugify = require("slugify");
router.get("/fetchNotesIrrespective/:id", async (req, res) => {
  try {
    const id = req.params.id;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ error: "Invalid Note ID format" });
    }
    const note = await Note.findById(id)
      .populate("user", "name  _id role profilePictureUrl")
      .populate("category", "name");
    if (!note) {
      return res.status(404).json({ error: "Note not found" });
    }
    res.status(200).json(note);
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ error: "Internal Server Error" });
  }
});
router.get("/fetchNoteBySlug/:slug", async (req, res) => {
  try {
    const slug = req.params.slug;
    const note = await Note.findOne({ slug: slug })
      .populate("user", "name _id role profilePictureUrl") 
      .populate("category", "name parent _id"); 
    if (!note) {
      console.warn(`Note not found with slug: ${slug}`);
      return res.status(404).json({ error: "Note not found" });
    }
    let ancestorPath = [];
    if (note.category && note.category._id) {
      ancestorPath = await getCategoryAncestors(note.category._id);
    }
    const noteObject = note.toObject();
    noteObject.ancestorPath = ancestorPath; 
    console.log(`Note found by slug ${slug}: ${note.title}`);
    res.status(200).json(noteObject); 
  } catch (err) {
    console.error("Error fetching note by slug:", err.message);
    if (err instanceof mongoose.Error.CastError) {
      return res.status(400).json({ error: "Invalid slug format" });
    }
    res.status(500).json({ error: "Internal Server Error" });
  }
});
async function getCategoryAncestors(categoryId) {
  if (!categoryId || !mongoose.Types.ObjectId.isValid(categoryId)) {
    return [];
  }
  let ancestors = [];
  let currentId = categoryId;
  try {
    while (currentId) {
      const category = await Category.findById(currentId)
        .select("_id name parent")
        .lean();
      if (!category) {
        break; 
      }
      ancestors.unshift({ _id: category._id, name: category.name });
      currentId = category.parent; 
    }
  } catch (err) {
    console.error("Error fetching ancestors for category", categoryId, err);
    return ancestors;
  }
  return ancestors;
}
router.get("/fetchNotesIrrespective", async (req, res) => {
  try {
    const allNotes = await Note.find({})
      .populate("user", "name")
      .populate("category", "name")
      .sort({ date: -1 });
    res.status(200).json(allNotes);
  } catch (err) {
    console.log(err);
    res.status(500).json({ error: "Internal Server Error" });
  }
});
router.get("/fetchallnotes", fetchuser, async (req, res) => {
  try {
    const requestingUser = await User.findById(req.user.id).select("role"); 
    if (!requestingUser) {
      return res.status(401).json({ error: "User not found or invalid token" });
    }
    let notes;
    const populateFields = [
      { path: "user", select: "name email profilePictureUrl" },
      { path: "category", select: "name" },
    ];
    if (requestingUser.role === "admin") {
      console.log(
        "Fetching all notes for admin user:",
        requestingUser.email || req.user.id,
      );
      notes = await Note.find({}).populate(populateFields).sort({ date: -1 });
    } else {
      console.log(
        "Fetching notes for regular user:",
        requestingUser.email || req.user.id,
      );
      notes = await Note.find({ user: req.user.id })
        .populate(populateFields)
        .sort({ date: -1 });
    }
    res.json(notes);
  } catch (error) {
    console.error("Error in /fetchallnotes:", error.message);
    res.status(500).json({ error: "Internal Server Error" });
  }
});
router.get("/fetchNotesIrrespectiveByType/:type", async (req, res) => {
  try {
    const type = req.params.type;
    let query = {};
    if (type && type !== "all") {
      const validTypes = Note.schema.path("type").enumValues;
      if (validTypes.includes(type)) {
        query.type = type;
      } else {
        console.warn(`Invalid type requested: ${type}`);
        return res.status(200).json([]);
      }
    }
    const notes = await Note.find(query)
      .populate("user", "name ")
      .sort({ date: -1 });
    res.status(200).json(notes);
  } catch (err) {
    console.error(err.message);
    res.status(500).json({ error: "Internal Server Error" });
  }
});
router.post(
  "/addnote",
  fetchuser,
  [
    body("title", "Enter a valid title").trim().isLength({ min: 3 }),
    body("description", "Description must be atleast 5 characters").isLength({
      min: 5,
    }),
    body("category", "Category is required")
      .isMongoId()
      .withMessage("Invalid Category ID format."),
    body("tag").optional().trim().isString(),
    body("isFeatured").optional().isBoolean(),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      console.error(
        "Validation errors in /addnote:",
        JSON.stringify(errors.array()),
      );
      return res.status(400).json({ success: false, errors: errors.array() });
    }
    try {
      const requestingUser = await User.findById(req.user.id).select(
        "role email",
      );
      if (!requestingUser) {
        return res
          .status(401)
          .json({ success: false, error: "User not found or invalid token." });
      }
      const { title, description, tag, category: categoryId } = req.body; 
      let isFeatured = req.body.isFeatured || false;
      const categoryExists = await Category.findById(categoryId);
      if (!categoryExists) {
        return res.status(400).json({
          success: false,
          errors: [
            { msg: "Selected category does not exist", param: "category" },
          ],
        });
      }
      if (isFeatured && requestingUser.role !== "admin") {
        console.warn(
          `User ${requestingUser.email || req.user.id} (role: ${
            requestingUser.role
          }) attempted to set isFeatured=true on add. Forcing to false.`,
        );
        isFeatured = false;
      }
      let baseSlug = slugify(title, {
        lower: true,
        strict: true,
        remove: /[*+~.()'"!:@]/g,
      });
      if (!baseSlug) {
        baseSlug = `note-${Date.now()}`;
      }
      let slug = baseSlug;
      let counter = 1;
      let existingNote = await Note.findOne({ slug: slug });
      while (existingNote) {
        counter++;
        slug = `${baseSlug}-${counter}`;
        console.log(
          `Slug collision detected for '${baseSlug}'. Trying new slug: ${slug}`,
        );
        existingNote = await Note.findOne({ slug: slug });
      }
      console.log(`Final generated slug for note '${title}': ${slug}`);
      const note = new Note({
        title,
        slug,
        description,
        tag: tag || "General",
        category: categoryId, 
        isFeatured,
        user: req.user.id,
      });
      const savedNote = await note.save();
      const populatedNote = await Note.findById(savedNote._id)
        .populate("user", "name email profilePictureUrl") 
        .populate("category", "name"); 
      res.status(201).json(populatedNote); 
    } catch (error) {
      console.error("Error in /addnote route:", error.message);
      if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
        return res.status(409).json({
          success: false,
          errors: [
            {
              msg: "A note with a very similar title already exists, resulting in a duplicate URL slug. Please modify the title slightly.",
              param: "title",
              location: "body",
            },
          ],
        });
      }
      res.status(500).json({ success: false, error: "Internal Server Error" });
    }
  },
);
router.put(
  "/updatenote/:id",
  fetchuser,
  restrictToOwnerOrAdmin, 
  [
    body("title", "Enter a valid title").optional().trim().isLength({ min: 3 }),
    body("description", "Description must be atleast 5 characters")
      .optional()
      .isLength({ min: 5 }),
    body("category", "Invalid Category ID format").optional().isMongoId(),
    body("tag").optional().trim(),
    body("isFeatured").optional().isBoolean(),
  ],
  async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ success: false, errors: errors.array() });
    }
    const noteToUpdate = req.note;
    try {
      const { title, description, tag, category: categoryId } = req.body;
      let clientIsFeatured = req.body.isFeatured;
      const updateFields = {};
      let slugNeedsUpdate = false;
      if (title !== undefined && title !== noteToUpdate.title) {
        updateFields.title = title;
      }
      if (description !== undefined) {
        updateFields.description = description;
        const words = description.split(/\s+/).filter(Boolean).length;
        const wordsPerMinute = 200;
        updateFields.readTimeMinutes = Math.max(
          1,
          Math.ceil(words / wordsPerMinute),
        );
      }
      if (tag !== undefined) updateFields.tag = tag;
      if (
        categoryId !== undefined &&
        categoryId !== noteToUpdate.category.toString()
      ) {
        const categoryExists = await Category.findById(categoryId);
        if (!categoryExists) {
          return res.status(400).json({
            success: false,
            errors: [
              { msg: "Selected category does not exist", param: "category" },
            ],
          });
        }
        updateFields.category = categoryId;
      }
      if (
        clientIsFeatured !== undefined &&
        req.requestingUser.role === "admin"
      ) {
        updateFields.isFeatured = clientIsFeatured;
      } else if (
        clientIsFeatured !== undefined &&
        req.requestingUser.role !== "admin"
      ) {
        console.warn(
          `Non-admin user ${req.user.id} tried to change isFeatured on update for note ${req.params.id}. Ignoring.`,
        );
      }
      if (Object.keys(updateFields).length === 0) {
        return res.status(400).json({
          success: false,
          error: "No valid fields provided for update",
        });
      }
      const updatedNote = await Note.findByIdAndUpdate(
        req.params.id,
        { $set: updateFields },
        { new: true, runValidators: true }, 
      )
        .populate("user", "name email profilePictureUrl")
        .populate("category", "name ");
      if (!updatedNote) {
        return res.status(404).json({
          success: false,
          error: "Note not found after update attempt.",
        });
      }
      res.json({ success: true, note: updatedNote }); 
    } catch (error) {
      if (error.code === 11000 && error.keyPattern && error.keyPattern.slug) {
        return res.status(409).json({
          success: false,
          error:
            "Updating this note would result in a duplicate URL slug. Please modify the title or slug slightly.",
        });
      }
      console.error("Error in /updatenote:", error.message);
      res.status(500).json({ success: false, error: "Internal Server Error" });
    }
  },
);
router.delete(
  "/deletenote/:id",
  fetchuser,
  restrictToOwnerOrAdmin,
  async (req, res) => {
    try {
      const deletedNote = await Note.findByIdAndDelete(req.params.id);
      res.json({ success: true, note: deletedNote }); 
    } catch (error) {
      console.error("Error in /deletenote:", error.message);
      res.status(500).json({ error: "Internal Server Error" });
    }
  },
);
router.get("/fetchNextNote", async (req, res) => {
  try {
    const { lastId, categoryIdOrSlug } = req.query; 
    const limit = parseInt(req.query.limit) || 9; 
    let query = {};
    if (categoryIdOrSlug && categoryIdOrSlug !== "all") {
      let categoryFilter = null;
      if (mongoose.Types.ObjectId.isValid(categoryIdOrSlug)) {
        categoryFilter = await Category.findById(categoryIdOrSlug).select(
          "_id",
        );
      } else {
        categoryFilter = await Category.findOne({
          slug: categoryIdOrSlug,
        }).select("_id");
      }
      if (categoryFilter) {
        query.category = categoryFilter._id;
      } else {
        console.warn(
          `Category filter specified (${categoryIdOrSlug}) but not found. Returning empty.`,
        );
        return res
          .status(200)
          .json({ success: true, notes: [], hasMore: false, nextLastId: null });
      }
    }
    if (lastId) {
      if (!mongoose.Types.ObjectId.isValid(lastId)) {
        return res
          .status(400)
          .json({ success: false, error: "Invalid lastId format" });
      }
      query._id = { $lt: lastId }; 
    }
    const notes = await Note.find(query)
      .sort({ _id: -1 }) 
      .limit(limit)
      .populate("user", "name profilePictureUrl") 
      .populate("category", "name"); 
    const nextLastId = notes.length > 0 ? notes[notes.length - 1]._id : null;
    let hasMore = false;
    if (nextLastId) {
      const remainingCountQuery = { ...query, _id: { $lt: nextLastId } };
      const remainingCount = await Note.countDocuments(remainingCountQuery);
      hasMore = remainingCount > 0;
    }
    res.status(200).json({
      success: true,
      notes,
      hasMore,
      nextLastId,
    });
  } catch (err) {
    console.error("Error in fetchNextNote:", err);
    res.status(500).json({ success: false, error: "Internal Server Error" });
  }
});
router.get("/featured/batch", async (req, res) => {
  try {
    const { lastId } = req.query;
    const limit = parseInt(req.query.limit) || 5;
    let query = { isFeatured: true };
    if (lastId) {
      if (!mongoose.Types.ObjectId.isValid(lastId)) {
        return res
          .status(400)
          .json({ success: false, error: "Invalid lastId format" });
      }
      query._id = { $lt: lastId };
    }
    const notes = await Note.find(query)
      .sort({ _id: -1 })
      .limit(limit)
      .populate("user", "name profilePictureUrl") 
      .populate("category", "name "); 
    const nextLastId = notes.length > 0 ? notes[notes.length - 1]._id : null;
    let hasMore = false;
    if (nextLastId) {
      const remainingCount = await Note.countDocuments({
        isFeatured: true,
        _id: { $lt: nextLastId },
      });
      hasMore = remainingCount > 0;
    }
    res.status(200).json({
      success: true,
      notes,
      hasMore,
      nextLastId,
    });
  } catch (err) {
    console.error("Error fetching featured notes batch:", err);
    res.status(500).json({ success: false, error: "Internal Server Error" });
  }
});
router.get("/featured", async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 3;
    const featuredNotes = await Note.find({ isFeatured: true })
      .populate("user", "name profilePictureUrl")
      .populate("category", "name ") 
      .sort({ date: -1 })
      .limit(limit);
    res.json({ success: true, notes: featuredNotes });
  } catch (err) {
    console.error(err.message);
    res.status(500).send("Internal Server Error");
  }
});
router.get("/search", async (req, res) => {
  try {
    const searchQuery = req.query.query;
    const limit = parseInt(req.query.limit) || 20; 
    if (
      !searchQuery ||
      typeof searchQuery !== "string" ||
      searchQuery.trim() === ""
    ) {
      return res.status(400).json({
        success: false,
        error:
          "Search query parameter is required and must be a non-empty string.",
      });
    }
    const notes = await Note.find({
      $or: [
        { title: { $regex: searchQuery, $options: "i" } },
        { description: { $regex: searchQuery, $options: "i" } },
        { tag: { $regex: searchQuery, $options: "i" } },
      ],
    })
      .populate("user", "name profilePictureUrl")
      .populate("category", "name ") 
      .sort({ date: -1 }) 
      .limit(limit);
    res.json({ success: true, notes: notes });
  } catch (err) {
    console.error("Search Error:", err.message);
    res.status(500).send("Internal Server Error");
  }
});
router.get("/recent", async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 5;
    const recentNotes = await Note.find({})
      .sort({ date: -1 })
      .limit(limit)
      .select("title _id date slug category tag") 
      .populate("category", "name "); 
    res.json({ success: true, notes: recentNotes });
  } catch (err) {
    console.error(err.message);
    res.status(500).send("Internal Server Error");
  }
});
router.get("/by-category/:categoryId", async (req, res) => {
  try {
    const { categoryId } = req.params;
    const { lastId } = req.query;
    const limit = parseInt(req.query.limit) || 9; 
    if (!mongoose.Types.ObjectId.isValid(categoryId)) {
      return res
        .status(400)
        .json({ success: false, error: "Invalid Category ID format" });
    }
    const category = await Category.findById(categoryId).select("_id name"); 
    if (!category) {
      return res
        .status(404)
        .json({ success: false, error: "Category not found" });
    }
    let query = { category: category._id };
    if (lastId) {
      if (!mongoose.Types.ObjectId.isValid(lastId)) {
        return res
          .status(400)
          .json({ success: false, error: "Invalid lastId format" });
      }
      query._id = { $lt: lastId };
    }
    const notes = await Note.find(query)
      .sort({ _id: -1 }) 
      .limit(limit)
      .populate("user", "name profilePictureUrl") 
      .populate("category", "name"); 
    const nextLastId = notes.length > 0 ? notes[notes.length - 1]._id : null;
    let hasMore = false;
    if (nextLastId) {
      const remainingCount = await Note.countDocuments({
        category: category._id, 
        _id: { $lt: nextLastId },
      });
      hasMore = remainingCount > 0;
    }
    console.log(
      `Category ${categoryId} Notes: Fetched ${notes.length}, HasMore: ${hasMore}, NextLastId: ${nextLastId}`,
    );
    res.json({
      success: true,
      notes,
      category: { name: category.name, _id: category._id }, 
      hasMore,
      nextLastId,
    });
  } catch (error) {
    console.error("Error fetching notes by category:", error);
    res.status(500).json({
      success: false,
      error: "Server Error fetching notes by category",
    });
  }
});
router.get("/by-category/:categoryId/titles", async (req, res) => {
  try {
    const { categoryId } = req.params;
    if (!mongoose.Types.ObjectId.isValid(categoryId)) {
      return res
        .status(400)
        .json({ success: false, error: "Invalid Category ID format" });
    }
    const categoryExists = await Category.findById(categoryId).select("_id");
    if (!categoryExists) {
      return res
        .status(404)
        .json({ success: false, error: "Category not found" });
    }
    const notes = await Note.find({ category: categoryId })
      .select("_id title slug") 
      .sort({ title: 1 }) 
      .lean(); 
    console.log(
      `Workspaceed ${notes.length} note titles for category ${categoryId}`,
    );
    res.json({ success: true, notes: notes });
  } catch (error) {
    console.error("Error fetching note titles by category:", error);
    res.status(500).json({
      success: false,
      error: "Server Error fetching note titles",
    });
  }
});
module.exports = router;

// FILE: setup_initial_categories.js
require("dotenv").config({ path: "./config.env" });
const mongoose = require("mongoose");
const Category = require("./models/Category"); 
const mongoURI = process.env.DATABASE;
const initialCategories = [
  {
    name: "JavaScript",
    description: "Posts related to JavaScript programming.",
  },
  {
    name: "Salesforce",
    description: "Posts about Salesforce CRM and platform.",
  },
  { name: "Sociology", description: "Posts related to sociological topics." },
  {
    name: "Life",
    description: "Posts about life experiences and reflections.",
  },
  { name: "Technology", description: "General technology posts." },
  {
    name: "Creative",
    description: "Posts about creative projects or processes.",
  },
  { name: "Tutorial", description: "How-to guides and tutorials." },
  { name: "News", description: "News related updates." },
];
async function setupCategories() {
  console.log("Connecting to MongoDB...");
  await mongoose.connect(mongoURI);
  console.log("Connected to MongoDB successfully.");
  let createdCount = 0;
  let skippedCount = 0;
  try {
    console.log("Attempting to create initial categories...");
    for (const catData of initialCategories) {
      const existing = await Category.findOne({
        name: { $regex: `^${catData.name}$`, $options: "i" },
      }); 
      if (existing) {
        console.log(`Category "${catData.name}" already exists. Skipping.`);
        skippedCount++;
      } else {
        const newCategory = new Category(catData);
        await newCategory.save();
        console.log(`Created category: "${newCategory.name}"`);
        createdCount++;
      }
    }
    console.log("--- Initial Category Setup Summary ---");
    console.log(`Created: ${createdCount}`);
    console.log(`Skipped (already existed): ${skippedCount}`);
  } catch (error) {
    console.error("An error occurred during category setup:", error);
  } finally {
    console.log("Disconnecting from MongoDB...");
    await mongoose.disconnect();
    console.log("Disconnected.");
  }
}
setupCategories();
